<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>全面理解React，实现自己的React &#8211; 积木村の研究所</title>
<meta name="description" content="通过实现一个简单的React, 来理解React的原理">
<meta name="keywords" content="react">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="全面理解React，实现自己的React">
<meta property="og:description" content="通过实现一个简单的React, 来理解React的原理">
<meta property="og:url" content="/react-implement/">
<meta property="og:site_name" content="积木村の研究所">





<link rel="canonical" href="/react-implement/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="积木村の研究所 Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">
<!-- Webfonts -->
<!--link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic"
rel="stylesheet" type="text/css" -->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(/images/triangular.png);}</style>


</head>

<body id="post" >

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="/images/self.jpg" alt="foio photo" class="author-photo">
					<h4>foio</h4>
					<p>QQ手机浏览器前端工程师</p>
				</li>
                <!--<li><a href="/about/">Learn More</a></li>-->
				<li>
					<a href="mailto:syszhpe@gmail.com"><i class="fa fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/tags/">All Tags</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="/react-implement/" rel="bookmark" title="全面理解React，实现自己的React">全面理解React，实现自己的React</a></h1>
        
        <h2>December 01, 2017</h2>
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>本文我们将依次从React元素、JSX语法、虚拟DOM、Component组件以及生命周期方法等方面，逐步深入了解React内部实现原理。</p>

<h2 id="1-react">1. React元素</h2>

<p>React元素用于描述真实的DOM组件或者自定义组件。</p>

<h3 id="1-react">(1). React元素的定义</h3>

<p>一个普通的React元素有两个属性：type和props。其中type为组件名称，对应着DOM元素类型（div、p...）或者自定义组件类型；props为组件属性，组件可以有一个children的数组特殊属性，数组中的每一个元素都是一个React元素。这样我们就可以通过React元素来描述组件之间的层级关系了。比如，如下React元素：</p>
<div class="highlight"><pre><code class="language-javasript" data-lang="javasript">const element = {
  type: "div",
  props: {
    id: "container",
    children: [
      { type: "a", props: { href: "/bar" } },
      { type: "span", props: {} }
    ]
  }
};
</code></pre></div>
<p>描述了如下DOM:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">"container"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">"/bar"</span><span class="o">&gt;&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div>
<p>对于Text元素，我们将其元素type设置为“TEXT ELEMENT”，以方便特殊处理。比如：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span>     <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="s2">"TEXT ELEMENT"</span><span class="p">,</span>
        <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="na">nodeValue</span><span class="p">:</span> <span class="s2">"Foo"</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>描述了：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&lt;</span><span class="nx">Text</span><span class="o">&gt;</span><span class="nx">Foo</span><span class="o">&lt;</span><span class="sr">/Text</span><span class="err">&gt;
</span></code></pre></div>
<h3 id="2-react">(2). 渲染React元素到浏览器</h3>

<p>首先，我们要模仿ReactDom.render方法: 接收一个元素和一个DOM容器，从而将元素描述的UI层次结构，渲染到浏览器的DOM容器中。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">parentDOM</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//获取元素的类型与属性信息</span>
    <span class="kr">const</span> <span class="p">{</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">props</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>

    <span class="c1">//需要对Text类型元素做特殊处理</span>
    <span class="kr">const</span> <span class="nx">isTextElement</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">===</span> <span class="s2">"TEXT ELEMENT"</span><span class="p">;</span>


    <span class="c1">//调用浏览器API创建相应的DOM</span>
    <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">isTextElement</span>
        <span class="p">?</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span>
        <span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">type</span><span class="p">);</span>

    <span class="c1">//处理DOM上的事件监听，以on开头的属性为事件handler属性</span>
    <span class="kr">const</span> <span class="nx">isListener</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">=&gt;</span> <span class="nx">name</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"on"</span><span class="p">);</span>

    <span class="c1">//调用浏览器API添加DOM事件处理函数</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">props</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isListener</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">eventType</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 取两位后</span>
        <span class="nx">dom</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">eventType</span><span class="p">,</span> <span class="nx">props</span><span class="p">[</span><span class="nx">name</span><span class="p">]);</span>
    <span class="p">});</span>

    <span class="c1">//处理DOM上的普通属性</span>
    <span class="kr">const</span> <span class="nx">isAttribute</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">isListener</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">name</span> <span class="o">!=</span> <span class="s2">"children"</span><span class="p">;</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">props</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isAttribute</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">props</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="c1">//处理React element上的特殊属性children</span>
    <span class="kr">const</span> <span class="nx">childElements</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[];</span>

    <span class="c1">//递归的渲染每一个React元素</span>
    <span class="nx">childElements</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">childElement</span> <span class="o">=&gt;</span> <span class="nx">render</span><span class="p">(</span><span class="nx">childElement</span><span class="p">,</span> <span class="nx">dom</span><span class="p">));</span>
    <span class="nx">parentDOM</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">dom</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div>
<p>到这里为止，我们就成功的创建了一个render函数，它可以将React Element描述的DOM层级结构，渲染到浏览器中。通过jsbin运行我们刚刚完成的代码：<a href="https://jsbin.com/tilaxucazi/1/edit?js,output">https://jsbin.com/tilaxucazi/1/edit?js,output</a></p>

<h2 id="2-jsx">2. JSX语法</h2>

<p>仅仅使用React Element来描述复杂的层级结构是非常困难的；本小结，我们使用JSX来简化对UI层级结构的描述，并使用Babel将JSX描述的层级结构
转换为React Element。对于上一节jsbin演示中的复杂的元素描述代码：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="s2">"div"</span><span class="p">,</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">id</span><span class="p">:</span> <span class="s2">"container"</span><span class="p">,</span>
        <span class="na">children</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="na">type</span><span class="p">:</span> <span class="s2">"span"</span><span class="p">,</span>
                <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
                    <span class="na">children</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="na">type</span><span class="p">:</span> <span class="s2">"TEXT ELEMENT"</span><span class="p">,</span>
                            <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="na">nodeValue</span><span class="p">:</span> <span class="s2">"Foo"</span> <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">]</span>
                <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="na">type</span><span class="p">:</span> <span class="s2">"a"</span><span class="p">,</span>
                <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
                    <span class="na">href</span><span class="p">:</span> <span class="s2">"/bar"</span><span class="p">,</span> <span class="na">children</span><span class="p">:</span> <span class="p">[</span>
                        <span class="p">{</span>
                            <span class="na">type</span><span class="p">:</span> <span class="s2">"TEXT ELEMENT"</span><span class="p">,</span>
                            <span class="na">props</span><span class="p">:</span> <span class="p">{</span> <span class="na">nodeValue</span><span class="p">:</span> <span class="s2">"bar"</span> <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">]</span>
                <span class="p">},</span>
            <span class="p">}</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div>
<p>我们可以使用如下简练的JSX语法即可描述：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="s2">"container"</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="nx">Foo</span><span class="o">&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">"/bar"</span><span class="o">&gt;</span><span class="nx">bar</span><span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div>
<p>JSX作为一种语法糖，极大的提升了我们描述复杂界面的效率，Babel则负责将JSX转换为React Element。为了使用Babel的魔法能力，我们需要提供一个createElement函数：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createElement</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">props</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">config</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">hasChildren</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">rawChildren</span> <span class="o">=</span> <span class="nx">hasChildren</span> <span class="p">?</span> <span class="p">[].</span><span class="nx">concat</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">:</span> <span class="p">[];</span>
  <span class="nx">props</span><span class="p">.</span><span class="nx">children</span> <span class="o">=</span> <span class="nx">rawChildren</span>
    <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">!==</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="p">?</span> <span class="nx">c</span> <span class="p">:</span> <span class="nx">createTextElement</span><span class="p">(</span><span class="nx">c</span><span class="p">));</span>
    <span class="c1">// 过滤-空-值, 剩下的-不属于-Object的值 -&gt; createTextElement -&gt; 变为 类型为TEXT_ELEMENT- Didact元素</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">props</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createTextElement</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 规范数据</span>
  <span class="k">return</span> <span class="nx">createElement</span><span class="p">(</span><span class="s2">"TEXT ELEMENT"</span><span class="p">,</span> <span class="p">{</span> <span class="na">nodeValue</span><span class="p">:</span> <span class="nx">value</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>Babel会将JSX语法转换成对createElement函数的调用：</p>

<p><a href="https://babeljs.io/repl/#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=PQKhAIAECsGcA9wGMBOBTAhgFzQUQDZoC2aAdluCMAFDVID2psFahJ54AvOABTXjgAPABMAlgDdwo4ZwBEDchlGk0KWQD5-AobAAOGUuoBi9eoOB6Dm7UOW6ArhXEZ89tHIBmp2eCwBPXXdZHHgsH2BrbUEMcAALdA85YAAjDDV1VJRzDEjzMXFNAEoAbiA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=false&timeTravel=false&sourceType=module&lineWrap=false&presets=react&prettier=false&targets=&version=6.26.0&envVersion=">点击查看</a></p>

<p>从而创建复杂的React Element层次结构。</p>

<p>到这里为止，我们就成功地借助于Babel，使用JSX语法来描述React Element的层级结构了：。通过jsbin运行我们刚刚完成的代码，体验一下JSX的魔力：<a href="https://jsbin.com/dinefeqiki/1/edit?js,output">https://jsbin.com/dinefeqiki/1/edit?js,output</a></p>

<p>Babel会使用文件头中的注释来决定&quot;构造Element的函数&quot;的名称：/** @jsx createElement <em>/，本文式例中，我们使用createElement。如果文件头中没有/</em>* @jsx  */注释，则默认使用React.createElement。</p>

<h2 id="3-dom">3. 虚拟DOM</h2>

<p>虚拟DOM是对真实DOM的抽象，通过对比虚拟DOM，准确的找出需要对真实DOM进行的操作，以最小的复杂度更新真实DOM。这个过程也在称为(Reconciliation)[<a href="https://reactjs.org/docs/reconciliation.html%5D%E3%80%82">https://reactjs.org/docs/reconciliation.html]。</a></p>

<p>为了便于组织虚拟DOM和真实DOM的关系，需要引入Instance的概念。一个Instance有3个属性</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">instance</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">element</span><span class="p">:</span> <span class="p">{},</span>            <span class="c1">//React元素的引用</span>
    <span class="na">dom</span><span class="p">:</span> <span class="p">{},</span>                <span class="c1">//真实浏览器DOM的引用</span>
    <span class="na">childInstances</span><span class="p">:</span> <span class="p">[]</span>      <span class="c1">//子节点的Instance引用</span>
<span class="p">}</span>
</code></pre></div>
<p>每个真实DOM节点都会有一个匹配的虚拟DOM节点：<code>Instance</code>。通过维护Instance和真实DOM节点的一一对应关系（如下图所示），我们就可以进行对虚拟DOM进行对比，来最小化的更新真实DOM。</p>

<p><img src="/images/react-isntance.png" alt="react-instance"></p>

<p>虚拟DOM对比算法的一个目标是尽可能避免-创建或删除Instance。创建和删除Instance意味着我们也将修改DOM树，所以我们重新利用Instance的次数越多，修改DOM树的次数就越少。引入虚拟DOM后，我们需要对前两节中的代码结构，进行大幅调整。</p>

<h3 id="1-render">(1). render函数</h3>

<p>引入虚拟DOM后，render函数的主要作用是：调用reconcile函数，进行DOM diff，和真实DOM更新。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//表示根节点的instance</span>
<span class="kd">let</span> <span class="nx">rootInstance</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">prevInstance</span> <span class="o">=</span> <span class="nx">rootInstance</span><span class="p">;</span> <span class="c1">//虚拟DOM的根节点</span>
  <span class="kr">const</span> <span class="nx">nextInstance</span> <span class="o">=</span> <span class="nx">reconcile</span><span class="p">(</span><span class="nx">container</span><span class="p">,</span> <span class="nx">prevInstance</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span> <span class="c1">//对比DOM diff，并更新真实DOM</span>
  <span class="nx">rootInstance</span> <span class="o">=</span> <span class="nx">nextInstance</span><span class="p">;</span> <span class="c1">// 新的虚拟DOM根节点</span>
<span class="p">}</span>

</code></pre></div>
<h3 id="2-reconcile">(2). reconcile函数</h3>

<p>reconile函数会使用React element元素创建虚拟DOM，并根据需要，对真实DOM进行最小化更新操作。该函数是React实现中最复杂的函数，我们将它拆分为两个子个函数分别实现。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">reconcile</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">,</span> <span class="nx">instance</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//虚拟的根节点为空时，使用当前React元素，创建新的虚拟DOM</span>
    <span class="kr">const</span> <span class="nx">newInstance</span> <span class="o">=</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span> 
    <span class="c1">//将真实DOM插入容器</span>
    <span class="nx">parentDom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">newInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span> 
    <span class="k">return</span> <span class="nx">newInstance</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">element</span> <span class="o">==</span> <span class="kc">null</span><span class="p">){</span>
    <span class="c1">//删除DOM</span>
    <span class="nx">parentDom</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//原有虚拟DOM节点类型与要创建的DOM节点类型一致时，可以重用dom以提升性能，只需要更新dom节点属性</span>
    <span class="nx">updateDomProperties</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">);</span>
    <span class="c1">//对instance子节点进行对比，以保证尽可能的重用DOM</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">childInstances</span> <span class="o">=</span> <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//使用当前React元素，创建新的虚拟DOM</span>
    <span class="kr">const</span> <span class="nx">newInstance</span> <span class="o">=</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
    <span class="c1">//将真实DOM替换容器中的原有DOM</span>
    <span class="nx">parentDom</span><span class="p">.</span><span class="nx">replaceChild</span><span class="p">(</span><span class="nx">newInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">newInstance</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="3-reconcilechildren">(3). reconcileChildren函数</h3>

<p>在真实的React实现中，需要元素提空额外属性（key）来匹配，以提升diff的效率。本文我们实现一个简版的diff算法，只比较children数组中相同位置的子节点。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// instance 旧</span>
  <span class="c1">// element 新</span>
  <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">childInstances</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">childInstances</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">nextChildElements</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[];</span>
  <span class="kr">const</span> <span class="nx">newChildInstances</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 新的孩子数组</span>

  <span class="c1">//选取新旧子节点数据组中最大的值</span>
  <span class="kr">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">childInstances</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">nextChildElements</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> 

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">childInstance</span> <span class="o">=</span> <span class="nx">childInstances</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kr">const</span> <span class="nx">childElement</span> <span class="o">=</span> <span class="nx">nextChildElements</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="c1">//调用reconcile创建子节点的虚拟DOM</span>
    <span class="cm">/*这里存在三种情况：
     * (1). childInstance和childElement都存在，则调用reconcile进行diff操作
     * (2). childInstance为空而childElement存在，调用调用reconcile创建新的instance
     * (3). childInstance存在而childElement为空，则调用reconcile进行删除操作，此时会返回null
     */</span>
    <span class="kr">const</span> <span class="nx">newChildInstance</span> <span class="o">=</span> <span class="nx">reconcile</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">childInstance</span><span class="p">,</span> <span class="nx">childElement</span><span class="p">);</span>
    <span class="nx">newChildInstances</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newChildInstance</span><span class="p">);</span>
  <span class="p">}</span>
   <span class="k">return</span> <span class="nx">newChildInstances</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">instance</span> <span class="o">=&gt;</span> <span class="nx">instance</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">//过滤null</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="4-instantiate">(4). instantiate函数</h3>

<p>instance函数是React实现中最关键的函数，它的作用是递归地创建、更新虚拟DOM。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">props</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>

  <span class="kr">const</span> <span class="nx">isTextElement</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">===</span> <span class="s2">"TEXT ELEMENT"</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">isTextElement</span>
    <span class="p">?</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span>
    <span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">type</span><span class="p">);</span>

  <span class="nx">updateDomProperties</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="p">[],</span> <span class="nx">props</span><span class="p">);</span> <span class="c1">//更新DOM节点的属性、绑定事件</span>

  <span class="c1">//递归地调用instantiate函数，创建虚拟DOM的子节点</span>
  <span class="kr">const</span> <span class="nx">childElements</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[];</span>
  <span class="kr">const</span> <span class="nx">childInstances</span> <span class="o">=</span> <span class="nx">childElements</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">instantiate</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">childDoms</span> <span class="o">=</span> <span class="nx">childInstances</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">childInstance</span> <span class="o">=&gt;</span> <span class="nx">childInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
  <span class="nx">childDoms</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">childDom</span> <span class="o">=&gt;</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">childDom</span><span class="p">));</span>

  <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">dom</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">childInstances</span> <span class="p">};</span>
  <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="5-updatedomproperties">(5). updateDomProperties函数</h3>

<p>updateDomProperties函数是调用浏览器DOM api对DOM进行修改的函数。该函数，首先从dom节点中删除所有旧属性，然后添加所有新属性。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">updateDomProperties</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">//判断是否为事件属性</span>
  <span class="kr">const</span> <span class="nx">isEvent</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">=&gt;</span> <span class="nx">name</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">"on"</span><span class="p">);</span>
  <span class="c1">//判断是否为普通属性</span>
  <span class="kr">const</span> <span class="nx">isAttribute</span> <span class="o">=</span> <span class="nx">name</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">isEvent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">name</span> <span class="o">!=</span> <span class="s2">"children"</span><span class="p">;</span>


  <span class="c1">//移除原有DOM节点上绑定的事件</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isEvent</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">eventType</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">dom</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="nx">eventType</span><span class="p">,</span> <span class="nx">prevProps</span><span class="p">[</span><span class="nx">name</span><span class="p">]);</span>
  <span class="p">});</span>

  <span class="c1">//移除原有DOM节点的普通属性</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isAttribute</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">//添加新属性</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isAttribute</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">dom</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nextProps</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
  <span class="p">});</span>

  <span class="c1">//添加新事件</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isEvent</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">eventType</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">substring</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">dom</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">eventType</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">[</span><span class="nx">name</span><span class="p">]);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<p>到目前为止，我们将上一节的render函数，拆分为5个功能独立的子函数，以增强了React的能力，可以重用DOM节点来避免对DOM树的大部分更改。重用DOM也有保持内部状态（如滚动位置或焦点）的作用。</p>

<p><a href="https://jsbin.com/tacazovuqo/1/edit?js,output">https://jsbin.com/tacazovuqo/1/edit?js,output</a></p>

<h2 id="4-component">4. Component组件</h2>

<p>上文第三节中我们实现了基本的虚拟DOM比较，能够在一定程度上复用DOM，但仍然有如下问题：</p>
<div class="highlight"><pre><code class="language-" data-lang="">（1）每次更改都会触发整棵虚拟DOM树的比较

（2）需要显式的调用render函数，来渲染最新状态

（3）不支持自定义组件
</code></pre></div>
<p>本节我们引入Component组件来解决这些问题。在上节中，为了便于组织虚拟DOM和真实DOM的关系，我们引入了Instance；它有三个属性，分别是React元素的引用、真实DOM的引用、子节点Instance数组的引用。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">instance</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">element</span><span class="p">:</span> <span class="p">{},</span>            <span class="c1">//React元素的引用</span>
    <span class="na">dom</span><span class="p">:</span> <span class="p">{},</span>                <span class="c1">//真实浏览器DOM的引用</span>
    <span class="na">childInstances</span><span class="p">:</span> <span class="p">[]</span>      <span class="c1">//子节点的Instance引用</span>
<span class="p">}</span>
</code></pre></div>
<p>而本节引入Component后，我们需要对Instance进行调整，新增了publicInstance，来表示对Component实例的引用；而一个Component实例内部又有一个对它自身Instance的引用：<strong>internalInstance。</strong>internalInstance的作用是为了在组件内部拿到子虚拟DOM的根节点，从而进行子树的diff操作，避免整个虚拟DOM进行diff操作。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">instance</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">element</span><span class="p">:</span> <span class="p">{},</span>            <span class="c1">//React元素的引用</span>
    <span class="na">dom</span><span class="p">:</span> <span class="p">{},</span>                <span class="c1">//真实浏览器DOM的引用</span>
  <span class="na">childInstances</span><span class="p">:</span> <span class="p">[],</span>       <span class="c1">//子节点的Instance引用</span>
  <span class="na">publicInstance</span><span class="p">:</span> <span class="p">{</span>  <span class="c1">//表示Component的引用</span>
    <span class="na">__internalInstance</span><span class="p">:</span> <span class="p">{}</span> <span class="c1">//对自身instance的引用, 用于在setState时通过组件this拿到instance以触发更新</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>相应的，引入Component后，虚拟DOM节点和真实DOM节点的对应关系也有变化：普通instance节点依然一一对应着真实DOM节点，而自定义组件的instance节点则对应着子树根节点对应的真实DOM。如下图红框所示为自定义组件：</p>

<p><img src="/images/react-component-instance.png" alt="react-component-instance"></p>

<p>引入Component后, React的element可能是一个自定义的组件, 我们需要一个用于创建自定义组件Component实例(publicInstance)的方法:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createPublicInstance</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">internalInstance</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 当元素进到这里来, 说明type是个自定义element的构造函数</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">props</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="c1">// 调用组件的构造函数，创建组件实例</span>
  <span class="kr">const</span> <span class="nx">publicInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">type</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
  <span class="c1">// 自定义组件对应的Instance引用, 用于在实例中通过this.__internalInstance获取组件对应的instance，以更新组件</span>
  <span class="nx">publicInstance</span><span class="p">.</span><span class="nx">__internalInstance</span> <span class="o">=</span> <span class="nx">internalInstance</span><span class="p">;</span> 
  <span class="k">return</span> <span class="nx">publicInstance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>所有的React组件都需要继承一个基类Component，该基类有一个构造函数和setState方法，其中setState方法会触发组件的更新</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">class</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">||</span> <span class="p">{};</span>
  <span class="p">}</span>

  <span class="c1">//用于更新组件的内部状态</span>
  <span class="nx">setState</span><span class="p">(</span><span class="nx">partialState</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">partialState</span><span class="p">);</span>
    <span class="c1">// 通过this.__internalInstance获取Component对应的instance，并通过updateInstance进行更新</span>
    <span class="nx">updateInstance</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">__internalInstance</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">updateInstance</span><span class="p">(</span><span class="nx">internalInstance</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//internalInstance是自定义组件对应的instance {element, dom, childInstances}</span>
  <span class="kr">const</span> <span class="nx">parentDom</span> <span class="o">=</span> <span class="nx">internalInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">internalInstance</span><span class="p">.</span><span class="nx">element</span><span class="p">;</span>
  <span class="c1">//调用reconile函数，进行虚拟DOM比较，并更新DOM树</span>
  <span class="nx">reconcile</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">,</span> <span class="nx">internalInstance</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>我们需要更新上一节实现的reconcile函数，以实现对自定义组件（Component）的支持：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">reconcile</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">,</span> <span class="nx">instance</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//虚拟的根节点为空时，使用当前React元素，创建新的虚拟DOM</span>
    <span class="kr">const</span> <span class="nx">newInstance</span> <span class="o">=</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span> 
    <span class="c1">//将真实DOM插入容器</span>
    <span class="nx">parentDom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">newInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span> 
    <span class="k">return</span> <span class="nx">newInstance</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">element</span> <span class="o">==</span> <span class="kc">null</span><span class="p">){</span>
    <span class="c1">//删除DOM</span>
    <span class="nx">parentDom</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span><span class="p">){</span>
    <span class="c1">//使用当前React元素，创建新的虚拟DOM</span>
    <span class="kr">const</span> <span class="nx">newInstance</span> <span class="o">=</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
    <span class="c1">//将真实DOM替换容器中的原有DOM</span>
    <span class="nx">parentDom</span><span class="p">.</span><span class="nx">replaceChild</span><span class="p">(</span><span class="nx">newInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">newInstance</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">element</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'string'</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">//原有虚拟DOM节点类型与要创建的DOM节点类型一致且为原生类型（非自定义类型），可以重用dom以提升性能，只需要更新dom节点属性</span>
    <span class="nx">updateDomProperties</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">,</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">);</span>
    <span class="c1">//对instance子节点进行对比，以保证尽可能的重用DOM</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">childInstances</span> <span class="o">=</span> <span class="nx">reconcileChildren</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">element</span><span class="p">);</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//逻辑到之有两个条件</span>
    <span class="c1">//（1）原有虚拟DOM节点类型与要创建的DOM节点类型一致</span>
    <span class="c1">//（2）element type为自定义类型，其中publicInstance是自定义组件的实例</span>
    <span class="c1">//更新自定义组件的属性</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">publicInstance</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
    <span class="c1">//原有孩子节点instance数组</span>
    <span class="kr">const</span> <span class="nx">oldChildInstance</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">childInstance</span><span class="p">;</span>
    <span class="c1">//调用自定义的render函数，创建自定义组件的孩子节点element</span>
    <span class="kr">const</span> <span class="nx">childElement</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">publicInstance</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span> <span class="c1">// 组件的render函数 </span>
    <span class="c1">//对比自定义组件的虚拟DOM，更新DOM</span>
    <span class="kr">const</span> <span class="nx">childInstance</span> <span class="o">=</span> <span class="nx">reconcile</span><span class="p">(</span><span class="nx">parentDom</span><span class="p">,</span> <span class="nx">oldChildInstance</span><span class="p">,</span> <span class="nx">childElement</span><span class="p">);</span>
    <span class="c1">//更新instance引用</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">dom</span> <span class="o">=</span> <span class="nx">childInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">;</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">childInstance</span> <span class="o">=</span> <span class="nx">childInstance</span><span class="p">;</span>
    <span class="nx">instance</span><span class="p">.</span><span class="nx">element</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span> 
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>instantiate函数的作用是将element转成为instance结构，它也需要额外的修改以支持自定义组件。在instantiate函数中，对于DOM类型的组件，我们需要调用document.createElement，而
对于自定义的组件，则需要调用createPublicInstance。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="p">{</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">props</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">isDomElement</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">type</span> <span class="o">===</span> <span class="s1">'string'</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">isDomElement</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">isTextElement</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">===</span> <span class="s2">"TEXT ELEMENT"</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">isTextElement</span>
      <span class="p">?</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span>
      <span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">type</span><span class="p">);</span>

    <span class="nx">updateDomProperties</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="p">[],</span> <span class="nx">props</span><span class="p">);</span> <span class="c1">//更新DOM节点的属性、绑定事件</span>

    <span class="c1">//递归地调用instantiate函数，创建虚拟DOM的子节点</span>
    <span class="kr">const</span> <span class="nx">childElements</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="kr">const</span> <span class="nx">childInstances</span> <span class="o">=</span> <span class="nx">childElements</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">instantiate</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">childDoms</span> <span class="o">=</span> <span class="nx">childInstances</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">childInstance</span> <span class="o">=&gt;</span> <span class="nx">childInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">);</span>
    <span class="nx">childDoms</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">childDom</span> <span class="o">=&gt;</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">childDom</span><span class="p">));</span>

    <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">dom</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">childInstances</span> <span class="p">};</span>
    <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="c1">//对于自定义类组件，创建对应的publicInstance</span>
    <span class="kr">const</span> <span class="nx">publicInstance</span> <span class="o">=</span> <span class="nx">createPublicInstance</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">instance</span><span class="p">);</span>
    <span class="c1">//调用自定义组件的render方法，获取child element</span>
    <span class="kr">const</span> <span class="nx">childElement</span> <span class="o">=</span> <span class="nx">publicInstance</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span> 
    <span class="c1">//创建child element的instance</span>
    <span class="kr">const</span> <span class="nx">childInstance</span> <span class="o">=</span> <span class="nx">instantiate</span><span class="p">(</span><span class="nx">childElement</span><span class="p">);</span> <span class="c1">// 递归 孩子拿到 { dom, element, childInstances }</span>
    <span class="kr">const</span> <span class="nx">dom</span> <span class="o">=</span> <span class="nx">childInstance</span><span class="p">.</span><span class="nx">dom</span><span class="p">;</span>
    <span class="c1">//返回自定义类型组件的instance，其中publicInstance为自定义组件的实例</span>
    <span class="c1">//自定义组件的instance有几个特殊的地方：</span>
    <span class="c1">//(1) childInstance不是数组，而是自定义组件的根节点对应的instance</span>
    <span class="c1">//(2) dom是自定义组件的根节点对应的DOM</span>
    <span class="c1">//(3) publicInstance是自定义组件类实例，内部维护着__internalInstance指向instance</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dom</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">childInstance</span><span class="p">,</span> <span class="nx">publicInstance</span> <span class="p">});</span>
    <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>目前为止，我们已经可以使用Component自定义组件，并且在更新组件内部状态时自动触发子树的重新渲染。
<a href="https://jsbin.com/xumixem/1/edit?js,output">https://jsbin.com/xumixem/1/edit?js,output</a></p>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="/tags/#react" title="Pages tagged react" class="tag">react</a></span>
        <span><a href="/react-implement/" rel="bookmark" title="全面理解React，实现自己的React">全面理解React，实现自己的React</a> was published on <span class="entry-date date published updated"><time datetime="2017-12-01T00:00:00+08:00">December 01, 2017</time></span></span>
        (revised: <span class="entry-date date modified"><time datetime="2017-12-01">12/01/2017</time></span>)
        <span class="author vcard"><span class="fn"><a href="/about/" title="About foio">foio</a></span></span>
        
      </footer>
    </div><!-- /.entry-content -->

    
	        

    
    
    <div class="read-more">
      
        <div class="read-more-header">
          <a href="/isomorphic-render-xss/" class="read-more-btn">Read More</a>
        </div><!-- /.read-more-header -->
        <div class="read-more-content">
          <h3><a href="/isomorphic-render-xss/" title="同构渲染的常见风险">同构渲染的常见风险</a></h3>
          <p>同构渲染状态传递过程中常见的问题 <a href="/isomorphic-render-xss/">Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="/react16-wried/" title="React16升级避坑指南">React16升级避坑指南</a></h4>
            <span>Published on September 10, 2017</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="/chrome-critical-css/" title="一种提取关键样式的方法">一种提取关键样式的方法</a></h4>
            <span>Published on July 01, 2017</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
      
    </div><!-- /.read-more -->
  </article>
</div><!-- /#main -->


<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2018 foio. 本站全部文章禁止转载,侵权必究. Powered by <a href="http://jekyllrb.com">Jekyll</a></span>

  </footer>
</div><!-- /.footer-wrapper -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-79866739-1', 'auto');
  ga('send', 'pageview');
</script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>
	        
</body>
</html>
